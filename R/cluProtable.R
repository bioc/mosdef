#' Extract functional terms enriched in the DE genes, based on clusterProfiler
#'
#' A wrapper for extracting functional GO terms enriched in a list of (DE) genes,
#' based on the algorithm and the implementation in the clusterProfiler package
#' 
#' #' Note: the feature length retrieval is based on the \code{\link{enrichGO}} function,
#' and requires that the corresponding TxDb packages are installed and available
#'
#' @param res_de A DESeqResults object created using \code{DESeq2}
#' @param dds A DESeqDataset object created using \code{DESeq2}
#' @param de_genes A vector of (differentially expressed) genes
#' @param bg_genes A vector of background genes, e.g. all (expressed) genes in the assays
#' @param top_de numeric, how many of the top differentially expressed genes to use for the enrichment analysis.
#'  Attempts to reduce redundancy. Assumes the data is sorted by padj (default in DESeq2).
#' @param min_counts numeric, min number of counts a gene needs to have to be included
#' in the geneset that the de genes are compared to. Default is 0, recommended only for advanced users.
#' @param mapping Which \code{org.XX.eg.db} to use for annotation - select according to the species
#' @param de_type One of: 'up', 'down', or 'up_and_down' Which genes to use for GOterm calculations:
#' @param keyType Gene format to input into enrichGO from clusterProfiler. If res_de and dds are used use "SYMBOL" for more
#' information check the enrichGO documentation
#' @param verbose Logical, whether to add messages telling the user which steps were taken
#' @param ... Further parameters to use for the go_enrich function from \code{clusterProfiler}
#'
#' @return A table containing the computed GO Terms and related enrichment scores
#' @export
#'
#'
#' @importFrom AnnotationDbi mapIds
#' @importFrom clusterProfiler enrichGO
#' @importFrom methods is
#' @importFrom S4Vectors mcols
#' @importFrom DESeq2 counts
#'
#'
#' @examples
#' library(airway)
#' library(DESeq2)
#' data(dds_airway, package = "mosdef")
#' data(res_airway, package = "mosdef")
#' library("AnnotationDbi")
#' library("org.Hs.eg.db")
#' library(clusterProfiler)
#' CluProde_airway <- cluproTable(
#'   res_de = res_airway,
#'   dds = dds_airway,
#'   mapping = "org.Hs.eg.db"
#' )
#'
cluproTable <- function(res_de = NULL,
                        dds = NULL,
                        de_genes = NULL,
                        bg_genes = NULL,
                        top_de = NULL,
                        min_counts = 0,
                        mapping = "org.Hs.eg.db",
                        de_type = "up_and_down",
                        keyType = "SYMBOL",
                        verbose = TRUE,
                        ...) {
  if (!is.null(res_de) & !is.null(dds)) {
    keyType <- "SYMBOL"
    # Making sure that if res_de and dds are provided the keytype can't be overwritten to be ENTREZ
    # or something similar as the genevectors this functions creates from the res_de and dds use SYMBOLS
    # therefore enrichGO would not run with a keytype that was set wrong before
  }

  ## Checks:

  # Check if de-type is correct
  # if(!(de_type %in% c("up_and_down","up", "down")))

  match.arg(de_type, choices = c("up_and_down", "up", "down"), several.ok = FALSE)


  # stop("The de_type argument must be one of: 'up_and_down', 'up', 'down'")


  # Check if there is any input at all
  if (is.null(c(de_genes, bg_genes, dds, res_de))) {
    stop(
      "Please provide one of the following forms of input: \n",
      "A vector of differentially expressed genes and a vector of backgoud genes. \n",
      "A DEseqDataset  and a DESeqResults generated by DESeq2."
    )
  }

  # Check if there only a res_de is given
  if (!is.null(res_de) & is.null(dds)) {
    stop("Please also provide a DESeq2Dataset (dds) object.")
  }

  # check if only dds is given
  if (!is.null(dds) & is.null(res_de)) {
    stop("Please also provide a DESeq2 result object.")
  }

  # Check if there only a bg but no de genes is given
  if (!is.null(bg_genes) & is.null(de_genes)) {
    stop("Please also provide a vector of  differentially expressed genes.")
  }

  # Check if there is only a de but no bg genes given
  if (!is.null(de_genes) & is.null(bg_genes)) {
    stop("Please also provide  a vector of background genes.")
  }


  # checking the additional topGO_method2


  if ((de_type == "up" | de_type == "down") && !is.null(de_genes)) {
    stop(
      "The argument de_type can only be used if a dds and a res_de object are provided:\n",
      "please either provide these objects or if you want to work with gene vectors set de_type to: 'up_and_down'"
    )
  }




  annot_to_map_to <- get(mapping)

  if (!is.null(res_de) && !is.null(dds)) {
    # Check if the inputs are the correct type

    if (!is(dds, "DESeqDataSet")) {
      stop("The provided `dds` is not a DESeqDataSet object, please check your input parameters.")
    }

    if (!is(res_de, "DESeqResults")) {
      stop("The provided `res_de` is not a DESeqResults object, please check your input parameters.")
    }

    # checking that results and dds are related
    ## at least a subset of dds should be in res
    if (!all(rownames(res_de) %in% rownames(dds))) {
      warning(
        "It is likely that the provided `dds` and `res_de` objects are not related ",
        "to the same dataset (the row names of the results are not all in the dds). ",
        "Are you sure you want to proceed?"
      )
    }

    # Check if DESeq was run on the dds
    if (!"results" %in% mcols(mcols(dds))$type) {
      stop("I couldn't find results in your dds. You should first run DESeq2::DESeq() on your dds.")
    }


    res_de$symbol <- AnnotationDbi::mapIds(annot_to_map_to,
      keys = row.names(res_de),
      column = "SYMBOL",
      keytype = "ENSEMBL",
      multiVals = "first"
    )
    res_de$entrez <- AnnotationDbi::mapIds(annot_to_map_to,
      keys = row.names(res_de),
      column = "ENTREZID",
      keytype = "ENSEMBL",
      multiVals = "first"
    )
    resOrdered <- as.data.frame(res_de[order(res_de$padj), ])


    if (de_type == "up_and_down") {
      de_df <- resOrdered[resOrdered$padj <= .05 & !is.na(resOrdered$padj), ]
    } else if (de_type == "up") {
      de_df <- resOrdered[resOrdered$padj <= .05 & !is.na(resOrdered$padj), ]
      de_df <- de_df[de_df$log2FoldChange >= 0, ]
    } else if (de_type == "down") {
      de_df <- resOrdered[resOrdered$padj <= .05 & !is.na(resOrdered$padj), ]
      de_df <- de_df[de_df$log2FoldChange <= 0, ]
    }

    de_genes <- de_df$symbol
    if (!is.null(top_de)) {
      top_de <- min(top_de, length(de_genes))
      de_genes <- de_genes[seq_len(top_de)]
    }
    bg_ids <- rownames(dds)[rowSums(counts(dds)) > min_counts]
    bg_genes <- AnnotationDbi::mapIds(annot_to_map_to,
      keys = bg_ids,
      column = "SYMBOL",
      keytype = "ENSEMBL",
      multiVals = "first"
    )
    if (verbose) {
      message(
        "Your dataset has ",
        nrow(de_df),
        " DE genes. You selected ",
        length(de_genes), " (", sprintf("%.2f%%", (length(de_genes) / nrow(de_df)) * 100), # sprintf format with 2 decimal places
        ") genes. You analysed all ",
        de_type,
        "-regulated genes"
      )
    }
  } else if (!is.null(c(bg_genes, de_genes))) {
    all_de <- length(de_genes)

    if (!is.null(top_de)) {
      top_de <- min(top_de, length(de_genes))
      de_genes <- de_genes[seq_len(top_de)]

      if (verbose) {
        message(
          "Your dataset has ",
          all_de,
          " DE genes.You selected ",
          length(de_genes), " (", sprintf("%.2f%%", (length(de_genes) / all_de) * 100), # sprintf format with 2 decimal places
          ") genes. You analysed all ",
          de_type,
          "-regulated genes"
        )
      }
    }
  }



  # bg_genes <- mapIds(annot_to_map_to,
  #     keys = bg_ids,
  #     column = "SYMBOL",
  #     keytype = "ENSEMBL",
  #     multiVals = "first"
  #   )





  res_enrich <- enrichGO(
    gene = de_genes,
    universe = bg_genes,
    OrgDb = mapping,
    keyType = keyType,
    ...
  )


  return(res_enrich)
}
